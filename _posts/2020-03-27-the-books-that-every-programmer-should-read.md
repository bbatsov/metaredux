---
layout: post
title: The Books That Every Programmer Should Read
date: 2020-03-27 09:26 +0200
categories: posts
tags:
- Meta
---

> I read relentlessly. -- Rich Hickey, creator of Clojure

Several years ago[^1] I did a talk at "HackConf" titled "The Books That Every
Programmer Should Read"[^2].  Back then the conference was geared mostly towards
young aspiring software engineers, so I wanted to present on a topic that they'd
find useful. Early on in my career access to high-quality educational resources
on programming was very limited - the Internet was quite barren by modern
standards and there were very few online resources, foreign books were very hard
to procure in Bulgaria, and there weren't that many experience people to learn
from. I'd tackle every book I could lay my hands onto, and as a result I wasted
a lot of valuable time that I could have utilized better. On the bright side - after a while
I could immediately tell if some book was going to help me level up my skills or not.
I wanted to share my
experience and help others prevent some of my mistakes, even if we live in a
very different world today, and books might be starting to lose some of their relevance.

While, I didn't feel that my talk was particularly special
in any way, it became one of my greatest hits and I've been often asked to discuss certain aspects of it.
Another thing that I've been asked to do was to put all the "good" books I mentioned during the talk in a list
that people can easily refer to.

## The Central Message

The central message of my talk was very simple - there are plenty of programming books out there, but the majority
of them are not worth your time and you'd probably not learn much from them. I tried to give everyone a simple recipe
to spot great books and hone in on them. A good book:

* ages very well
* covers topics that are applicable in a broad spectrum of programming languages and frameworks
* is written by practitioners (as opposed to academics/professional writers)
* goes way beyond the basics and teaches you how to effectively use a certain technology
* explains complex concepts in simple terms
* challenges the way you think and pushes you to expand your mind

I made the case that in general no one should read more than 1 reference per some technology (and for frameworks
even this might be too much) and that usually there are only a couple of references in a certain domain that are
much better than everything else out there.

I've also tried to make the point that after a certain point it doesn't pay off very well to dig deeper and deeper
into the same subject matter, and that you should consider expanding your knowledge horizontally - e.g. if you're
an OOP expert you should start exploring functional or logical programming; if you're a back-end developer you should learn about the front-end technologies and so on. Ultimately, ideas matter much more
than any concrete implementation of those ideas.

## The Reading List

It was probably not apparent in my talk, but I had picked some of my favourite books in all the areas that
I consider essential for the success of a programmer - e.g. CS fundamentals, operating systems, effective usage of
a language/technology stack, software design, etc. You don't really need to read a dozen books on CS fundamentals or
operating systems and some of the books listed cover more or less the same ground.

Bellow is a listing of all the "good" books, grouped in categories.

### CS Fundamentals

* [Inside the Machine](https://www.amazon.com/Inside-Machine-Introduction-Microprocessors-Architecture/dp/1593276680)
* [Code: The Hidden Language of Computer Hardware and Software](https://www.amazon.com/Code-Language-Computer-Hardware-Software/dp/0735611319)
* [Concrete Mathematics](https://www.amazon.co.uk/Concrete-Mathematics-Foundation-Computer-Science/dp/0201558025)
* [Structure and Interpretation of Computer Programs](https://mitpress.mit.edu/sites/default/files/sicp/full-text/book/book.html)
* [How to Design Programs](https://htdp.org/)
* [The Algorithm Design Manual](http://www.algorist.com/)
* [Introduction to Algorithms](https://www.amazon.com/Introduction-Algorithms-3rd-MIT-Press/dp/0262033844)
* [Compiler Principles, Techniques and Tools](https://www.amazon.com/Compilers-Principles-Techniques-Tools-2nd/dp/0321486811)

### Operating Systems

* [Modern Operating System](https://www.amazon.com/Modern-Operating-Systems-Andrew-Tanenbaum/dp/013359162X)
* [Advanced Programming in the Unix Environment](https://www.amazon.com/Advanced-Programming-UNIX-Environment-3rd/dp/0321637739)
* [Unix Network Programming, Vol. 1](https://www.amazon.com/Unix-Network-Programming-Sockets-Networking/dp/0131411551), [Vol. 2](https://www.amazon.com/UNIX-Network-Programming-Interprocess-Communications/dp/0132974290)
* [UNIX and Linux System Administration Handbook](https://www.amazon.com/UNIX-Linux-System-Administration-Handbook/dp/0134277554)
* [The Design and Implementation of the FreeBSD Operating System](https://www.amazon.com/Design-Implementation-FreeBSD-Operating-System/dp/0201702452)

### References

* [The C Programming Language](https://www.amazon.com/Programming-Language-2nd-Brian-Kernighan/dp/0131103628)
* [Programming Ruby](https://pragprog.com/book/ruby4/programming-ruby-1-9-2-0)
* [The Well Grounded Rubyist](https://www.amazon.com/Well-Grounded-Rubyist-Covers-Ruby-1-9-1/dp/1933988657)
* [Learn You a Haskell for Great Good](http://learnyouahaskell.com/)
* [Practical Common Lisp](http://www.gigamonkeys.com/book/)
* [Land of LISP](http://landoflisp.com/)
* [The Little Schemer](https://mitpress.mit.edu/books/little-schemer-fourth-edition)
* [LISP (LISP In Small Pieces)](https://www.amazon.com/Lisp-Small-Pieces-Christian-Queinnec/dp/0521545668)

### Effective Usage

* [The Elements of Style](https://www.amazon.co.uk/Elements-Style-William-Strunk-Jr/dp/020530902X)
* [The Elements of Programming Style](https://www.amazon.com/Elements-Programming-Style-2nd/dp/0070342075)
* [Effective C++](https://www.amazon.com/Effective-Specific-Improve-Programs-Designs/dp/0321334876)
* [Effective Java](https://www.amazon.com/Effective-Java-Joshua-Bloch/dp/0134685997)
* [Java Concurrency in Practice](https://www.amazon.com/Java-Concurrency-Practice-Brian-Goetz/dp/0321349601)

### Software Design

* [Code Complete](https://www.amazon.com/Code-Complete-Practical-Handbook-Construction/dp/0735619670)
* [Domain-Driven Design](https://www.amazon.com/Domain-Driven-Design-Tackling-Complexity-Software/dp/0321125215)
* [Clean Code](https://www.amazon.com/Clean-Code-Handbook-Software-Craftsmanship/dp/0132350882)
* [Refactoring: Improving the Design of Existing Code](https://martinfowler.com/books/refactoring.html)
* [Practical Object-Orientetd Design in Ruby](https://www.amazon.com/Practical-Object-Oriented-Design-Ruby-Addison-Wesley/dp/0321721330)
* [Growing Object-Oriented Software Guided by Tests](https://www.amazon.com/Growing-Object-Oriented-Software-Guided-Tests/dp/0321503627)

### Productivity

* [From Bash to Z Shell](https://www.apress.com/gp/book/9781590593769)
* [Extreme Programming Explained](https://www.amazon.com/Extreme-Programming-Explained-Embrace-Change/dp/0321278658)

### Project Management

* [Predicting the Unpredictable](https://www.amazon.com/Predicting-Unpredictable-Pragmatic-Approaches-Estimating-ebook/dp/B00ZL05FYA)

### Meta

* [The Passionate Programmer](https://www.amazon.com/Passionate-Programmer-Remarkable-Development-Pragmatic-ebook/dp/B00AYQNR5U)
* [Thinking, Fast and Slow](https://www.amazon.com/Thinking-Fast-Slow-Daniel-Kahneman/dp/0374533555)
* [Godel, Escher, Bach](https://www.amazon.com/G%C3%B6del-Escher-Bach-Eternal-Golden/dp/0465026567)

## The Greatest Hits

I realize the list looks daunting and probably few people will have the time to
go over all the books in it. Many of them are definitely not light bedside
reading material. I have to admit there are some (many) books on the list that I
didn't finish myself. If I had to narrow down the list to the 3 most important
(impactful) books there those would be:

* Structure and Interpretation of Computer Programs
* The Elements of Style
* Code Complete
* Thinking Fast and Slow

Seems, I've made an off-by-one error, but you'll forgive me.

## The Sequel

There are many great books that I didn't mention in that talk (mostly due to time constraints). I'll guess I'll have to do a follow-up blog post for them. Generally speaking, I wanted to give people an idea
of what a quality book means and I was certain they'd be able uncover more of those. Teach a person to fish and all that jazz...

That being said, I wouldn't mind following up on my original talk with a sequel that expands on the basic ideas I outlined there and refines the list of books presented. There were
a couple of topics that I intentionally avoided (peopleware/soft skills, leadership), so there's definitely some more ground to cover.
Not to mention I read quite a few other great books since 2015. And I should probably do it in English next time!

## Epilogue

I think this is the only blog post that I've planned to write for 5 years before
it became a reality.  Better late than never, right? It took me quite a while to
get to it, but this gave me extra time to reflect on my talk. Sometimes even I
manage to find a different message in my presentations after ruminating on them
for a while.

I hope this post will inspire you to do some quality reading during the
lockdown[^3] and introduce a bit of joy in your life. It'd be nice of something good came out of it.  By the way, why
don't you share in the comments your favourite books? I'd love to get some
reading ideas myself!

[^1]: Way back in 2015.
[^2]: You can find a recording of the talk [here](https://www.youtube.com/watch?v=H6OQ2RESp4s). (it's in Bulgarian)
[^3]: As I write this in Spring 2020, much of the world's population is under lockdown, because of the ongoing COVID-19 pandemic.
